<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-17 with Biruk</title>
    <script src="lesson17.js"></script>
    <link rel="stylesheet" href="/lesson-16/lesson16.css">
    <img id="norImg" src="/JavaScript-logo.png" alt="">
</head>
<body>
    <h1 id="speH1">LESSON-17: <span id="spePara">FUNCTIONS</span></h1>
    <u><h2>Part-One</h2></u>
    <h2 id="spePara">FUNCTIONS</h2>
    <p>
        We talked about functions in the chapter on variables, when we discussed the scope of visibility of local variables declared with the keyword var. 
        We learned on this occasion what functions are, but in this chapter, we will take a much closer look at them, expanding our knowledge on the subject.
        <br><br>
        So <b id="front">what is function</b>? It's a separated piece of code, constituting a certain closed logical whole, intended to perform a specific task. 
        We usually assign a name to such a separated piece of code. With this name, we can call it (execute it) many times in different places of the program.
        <br><br>
        This is a simplification, because there are functions that do not have a name, for example, anonymous functions (we will talk about them later). 
        For the time being, let’s assume that a function has a name, which we give when declaring it. This name is used when calling the function, in other words, 
        when running the code contained in it.
        <br><br>
        The declaration and calling of functions are independent of each other, which we will see in a moment.
    </p>
    <h3 id="noticed">why do we use functions?</h3>
    <p >
        There are many reasons, one of the most important being to divide the code into some logically independent parts. 
        Such modularity increases the readability of the code – it is easier to write and analyze a long program that is not a sequence of single instructions.
        It also allows for easy testing of code fragments closed in functions independently of the rest of the program.
        <br><br>
        A very important reason for using a function is the reuse of code – if you repeat the same sequence of instructions in the program in many places, 
        you can close this sequence in a function, and in those places you only have to call the function.
        <br><br>
        Apart from reducing the amount of code in a program (thus increasing its readability), 
        it also means that if you need to make some changes in this sequence of instructions, 
        you have to do it only once, inside the function. If we didn’t use a function in this situation, 
        we would have to make changes independently in every place where this sequence of instructions appeared in the code.
        <br><br>
        Let's take a look at a simple program, written without any functions.
        <pre>
            <code>
                let temperatures;
                let sum;
                let mean_Temp;
                //

                temperatures = [
                12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21,
                20, 19, 17, 16,
                ];
                sum = 0;
                //

                for (let i = 0; i < temperatures.length; i++) {
                sum += temperatures[i];
                }
                //

                mean_Temp = sum / temperatures.length;
                console.log(`mean : ${mean_Temp}`); // mean : 16.666666666666668
                //
                //

                temperatures = [
                17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24,
                21, 19, 18, 17, 16,
                ];
                sum = 0;
                //

                for (let i = 0; i < temperatures.length; i++) {
                sum += temperatures[i];
                }
                //

                mean_Temp = sum / temperatures.length;
                console.log(`mean : ${mean_Temp}`); // mean : 18.083333333333332

            </code>
        </pre>
        <p>
            The program will calculate and display the mean daily temperature on the basis of the provided data (24 temperature measurements, in hourly intervals, 
            starting from midnight). In the program, we declare the variable temperatures, which will be a 24-element table containing the obtained measurements.
            <br><br>
            We have measurements for two successive days, for which we will make calculations. The mean temperature is of course calculated by summing up all values 
            and dividing the result by their number.
            <br><br>
            At first glance, you can see that the code fragment responsible for a calculation is repeated twice. In two places of the program, 
            we use the same sequence of instructions, so it would be worth thinking about creating a function out of them.
            <br><br>
            We will do it in several stages, introducing some new concepts related to functions. Let's start with a function declaration.
        </p>
    </p>
    <h2 id="spePara">DECLARING FUNCTIONS</h2>
    <p>
        As with variables, functions need to be declared before we can use them. The syntax for function declaration looks like this:
        <pre>
            <code>
                function function_name() {
                    block of code;
                }
            </code>
        </pre>
        <p>
            This type of function declaration in JavaScript is called a function statement. 
            A function statement starts with the <b id="front">function</b> 
            keyword followed by the function name. Function names need to follow the same rules as variable names, 
            and should also be meaningful. After the function name, there are parentheses that can optionally have function parameters, 
            which we’ll discuss in a while. After the parentheses comes the function body, 
            which is made from any number of statements (a code block).
            <br><br>
            So let's try to declare a function according to these rules, which will contain a fragment of our program code calculating 
            the mean daily temperature. We will call it <b id="front">get_temp_mean</b>. For now, the function will use variables, 
            declared outside of it (in the surrounding context). In fact, it is practically never done that way, 
            but we will deal with it at one of the subsequent stages.
            <pre>
                <code>
                    let temperature;
                    let sum_of_Temperature ;
                    let temp_mean;

                    //
                    //declare function

                    function get_temp_mean() {
                    sum_of_Temperature = 0;
                    for (let i = 0; i < temperature.length; i++) {
                        sum_of_Temperature += temperature[i];
                    }
                    temp_mean = sum_of_Temperature / temperature.length;
                    }
                </code>
            </pre>

        </p>

    </p>
    <h2 id="spePara">CALLING FUNCTIONS</h2>
    <p>
        To call a function, we need to write a function name and follow it with parentheses. Our complete example should therefore look like this:
        <pre>
            <code>
                let temperature_2;
                let sum_of_Temperature_2;
                let temp_mean_2;

                function get_temp_mean_2() {
                sum_of_Temperature_2 = 0;
                for (let i = 0; i < temperature_2.length; i++) {
                    sum_of_Temperature_2 += temperature_2[i];
                }
                temp_mean_2 = sum_of_Temperature_2 / temperature_2.length;
                }
                //
                //
                temperature_2 = [
                12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21,
                20, 19, 17, 16,
                ];
                get_temp_mean_2();
                console.log(`mean : ${temp_mean_2}`); // mean : 16.666666666666668
                //
                temperature_2 = [
                17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24,
                21, 19, 18, 17, 16,
                ];
                get_temp_mean_2();
                console.log(`mean : ${temp_mean_2}`); // mean : 18.083333333333332
            </code>
        </pre>
        <p>
            At the beginning of the program, after the variable declaration, we have the <b id="front">get_temp_mean_2</b> function declaration.
            <br><br>
            In the later part of the code, we call it twice by writing <b id="front">get_temp_mean_2()</b>. Each call causes the program to jump into the function code, 
            execute its instructions and return to the next instruction after the function call.
            <br>
            Simple, isn't it? 
            <br><br>
            Usually, functions are declared before they are called, mostly at the beginning of the code. However, this is only a good practice, 
            which increases the readability of the code, not a JavaScript syntax requirement. Function declarations are automatically moved to the 
            top of the scope, so we can use them before the declaration, as long as they are in the scope.
            <br><br>
            So the code:
            <pre>
                <code>
                    

                    let name = 'Biruk Fekadu';
                    //
                    //declaring before calling

                    function get_user_info(){
                    console.log(`user-name : ${name}`);
                    }
                    //
                    //calling the function

                    get_user_info(); // user-name : Biruk Fekadu
                </code>
            </pre>
            <p>
                will work exactly the same as:
                <pre>
                    <code>
                        let user_name = "Fekadu Tolesa";
                        get_user_name(); // user-name : Fekadu Tolesa
                        //
                        function get_user_name() {
                        console.log(`user-name : ${user_name}`);
                        }
                    </code>
                </pre> 
                <p>
                    So we already know what a <b id="front">declaration and a function call are</b>. It is time to take a closer look at its contents. 
                    Let's start with the variables we use in it.
                </p>
            </p>
        </p>
    </p>
    <h2 id="spePara">FUNCTIONS - local variables</h2>
    <p>
        Let's try to make a small change to our program calculating the mean temperature.
        <br><br>
        Do you remember what local variables are?
        <br><br>
        This is how we call the variables that are declared and used in some limited scope 
        and are not visible in the whole program, which means that we can only use them inside that particular scope.
        <br><br>
        Variables declared with the <b id="spePara">let</b> keyword are local inside the code block (i.e. inside the range limited by curly brackets), 
        while variables declared with the var keyword are local inside the function block. So if you declare a variable inside a function block, 
        whether using let or var, it will only be visible (and usable) inside the function block. This is very useful, 
        because usually the variables you use inside a function are not needed outside of it.
        <pre>
            <code>
                let temperature_3;
                let temp_mean_3;
                //
                //declaring function
                function get_temp_mean_3() {
                let sum_of_Temperature_3 = 0;
                for (let i = 0; i < temperature_3.length; i++) {
                    sum_of_Temperature_3 += temperature_3[i];
                }
                temp_mean_3 = sum_of_Temperature_3 / temperature_3.length;
                }
                //
                //
                temperature_3 = [12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21, 20, 19, 17, 16];
                get_temp_mean_3();
                console.log(`mean : ${temp_mean_3}`); // mean : 16.666666666666668
                //
                temperature_3 = [17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24, 21, 19, 18, 17, 16];
                get_temp_mean_3();
                console.log(`mean : ${temp_mean_3}`); // mean : 18.083333333333332
            </code>
        </pre>
        <p>
            In our code, an example of such a variable is <b id="spePara">sum_of_Temperature_3</b>.
            <br><br>
            Although we have declared it outside the <b id="spePara">get_temp_mean_3</b> function (it is a global variable), we only refer to it inside 
            the function. A global declaration is therefore unnecessary.
            <br><br>
            Let's put it in order, declaring <b id="spePara">sum_of_Temperature_3</b> locally.
            <br><br>
            The behavior of the program is the same, but the code has gained some clarity. The sum variable is now local, it can only be used inside the
            <b id="spePara">get_temp_mean_3</b> function (which is enough for us, because it was not needed for anything outside the function). <br><br>
            In general, we should strive to keep the function code as separate from the surrounding context as possible, among other things by 
            not using global variables inside it.In our example, there are two more such variables: temperatures and meanTemp.The latter, meanTemp, 
            is used inside the function to store and return the calculated result.
            <br><br>
            Let's deal with it.
        </p>
    </p>
    <h2 id="spePara">THE <span id="front" style="font-style: italic; font-family: monospace;">return</span> STATEMENT</h2>
    <p>
        Functions that have been called execute a sequence of instructions contained in their body. 
        The result of this execution may be a certain value that we may want to store in some variable. 
        The return keyword comes to help us in this case. What exactly is <b id="front">return</b> for?
        <br><br>
        <li id="list"><b id="front">First</b>, it causes the function to end exactly where this word occurs, even if there are further instructions.</li>
        <li id="list"><b id="front">Second</b>, it allows us to return a given value from inside the function to the place where it was called.</li>
        <p>
            Let's move away for a moment from our example with mean temperature calculation and play with a slightly simpler code. 
            The <b id="front">showMsg</b> function contains only two <b id="spePara">console.logs</b> separated by return.
            <pre>
                <code>
                    function showMsg() {
                        console.log("Message-1");
                        return;
                        console.log("Message-2");
                      }
                      showMsg(); // Message-1
                </code>
            </pre>
            <p>
                As expected, the call ends up displaying only the first message "message 1", then the <b id="front">return</b> interrupts the function. 
                In practice, using <b id="front">return</b> here would not make much sense. It causes the <b id="front">console.log("message 2")</b> to never be called. 
                So it would be easier not to write a second <b  id="front">console.log</b> call at all.
                <br><br>
                However, using the conditional instructions, we can, for example, react to errors inside the function, and in certain situations interrupt the function 
                immediately.
            </p>
        </p>
        <p>
            As we said, <b id="front">return</b> allows us not only to terminate a function. If we place some expression (literal, variable, function call) immediately 
            after the return keyword, 
            the value of this expression will be returned by the completed function to the place where it was called. You can then, for example, assign the returned value 
            to a variable. 
            Let's take a look at an example of the getTrue function.
            <br><br>
            In the example, we declare a simple <b id="front">getTrue</b> function, which always returns true. Pay attention to the function call – we store the result of
             this call in the test variable. 
            As you can guess, this variable will have the true value.
            <pre>
                <code>
                    function getTrue() {
                        return true;
                      }
                      //
                      let test = getTrue();
                      console.log(test); // true
                </code>
            </pre>
        </p>
        <p>
            Let's go back to the example with mean temperatures.
            <br><br>
            Until now, the calculations made inside the <b id="spePara">get_temp_mean_</b> function have been performed on the global variable <b id="spePara">temp_mean_</b>. 
            We will change this. 
            Inside the function, we will declare the local <b id="front">result</b> variable, which will contain the calculated result, and use <b id="front">return</b> 
            to return it. 
            The global variable <b id="spePara">temp_mean_</b> will contain the result of the function call, that is, the first time, <b id="normal">16.666666666666668</b> 
            and the second time, <b id="normal">18.083333333333332</b>.
            <br><br>
            <pre>
                <code>
                    let temperature_4;
                    let temp_mean_4;
                    //
                    function get_temp_mean_4() {
                      let sum_of_Temperature_4 = 0;
                      let result;
                      for (let i = 0; i < temperature_4.length; i++) {
                        sum_of_Temperature_4 += temperature_4[i];
                      }
                      result = sum_of_Temperature_4 / temperature_4.length;
                    
                      return result;
                    }
                    //
                    temperature_4 = [
                      12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21,
                      20, 19, 17, 16,
                    ];
                    
                    temp_mean_4 = get_temp_mean_4();
                    console.log(`mean---: ${temp_mean_4}`); // mean---: 16.666666666666668
                    //
                    temperature_4 = [
                      17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24,
                      21, 19, 18, 17, 16,
                    ];
                    
                    temp_mean_4 = get_temp_mean_4();
                    console.log(`mean---: ${temp_mean_4}`); // mean---: 18.083333333333332
                </code>
            </pre>
            <p>
                The <b id="spePara">result</b> variable is actually only used to temporarily store the value to be returned. So we can simplify the function code even more. 
                We will skip the <b id="spePara">result</b> variable by placing the appropriate operation directly after <b id="spePara">return</b>.
                <pre>
                    <code>
                        function get_temp_mean_5() {
                            sum_of_Temperature_5 = 0;
                            for (let i = 0; i < temperature_5.length; i++) {
                              sum_of_Temperature_5 += temperature_5[i];
                            }
                            return sum_of_Temperature_5/temperature_5.length;
                          }                          
                    </code>
                </pre>
                <p>
                    The <b id="spePara">temp_mean_</b> variable has also become slightly redundant. We store the result of the function call in it, which is then displayed on the console. 
                    This can also be simplified by placing the <b id="spePara">get_temp_mean_</b> function call directly in <b id="spePara">console.log</b> (without the use of the 
                    <b id="spePara">temp_mean_</b> variable).
                    <pre>
                        <code>
                            let temperature_6;
                            //
                            function get_temp_mean_6() {
                            let sum_of_Temperature_6 = 0;
                            for (let i = 0; i < temperature_6.length; i++) {
                                sum_of_Temperature_6 += temperature_6[i];
                            }
                            return sum_of_Temperature_6 / temperature_6.length;
                            }
                            //
                            temperature_6 = [
                            17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24,
                            21, 19, 18, 17, 16,
                            ];
                            console.log(`mean---: ${get_temp_mean_6}`);
                            //
                            //
                            temperature_6 = [
                            12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21,
                            20, 19, 17, 16,
                            ];
                            console.log(`mean---: ${get_temp_mean_6}`);
                        </code>
                    </pre>
                </p>
                <p>
                    Our <b id="spePara">get_temp_mean_6</b> is slowly beginning to look like a normal function. It is a logically independent piece of code, it returns a calculated value, 
                    and it operates on local variables. 
                    There is one small problem left to solve. We count the mean using the data contained in the global variable temperatures. And the function should be independent of what is 
                    happening outside it. At the same time, it should allow us to calculate the mean value for different data. How do we reconcile these two conflicting demands?
                    <br><br>
                    The function parameters are used for this.
                </p>
            </p>
        </p>
    </p>
    <h2 id="spePara">PARAMETERS</h2>
    <p>
        First of all, the use of parameters in functions is optional. There may be functions that do not have parameters, as we have seen in our previous examples, 
        just as there may be functions that do not return values. 
        However, most often we create functions that have defined parameters and return values.
        <br><br>
        In JavaScript, a function’s parameters appear in its declaration. These are names separated by commas, placed in parentheses after the function name. 
        Each parameter inside a function will be treated as a local variable. 
        A function whose definition specifies the parameters must be invoked in an appropriate way. When such a function is called, the values (literals, variables, 
        function calls) should be placed in parentheses after its name, 
        and are treated as parameters inside the function. The values given during a call are called arguments. Arguments, if there is more than one, 
        are separated by commas and must be passed in the same order as the parameters 
        we define in the function declaration.
        <br><br>
        Let's look at a simple function that adds two values. We will call it add.
        <pre>
            <code>
                function add(first_number, second_number) {
                    return first_number + second_number;
                  }
                  
            </code>
        </pre>
        <p>
            In the function declaration, in parentheses, we put two parameters: <b id="spePara">first</b> and <b id="spePara">second</b>. The names of the parameters, 
            just like the variables, should be related to their purpose – in this case, 
            we have done it differently to emphasize that the order of the parameters is important. 
            Inside the add function, these parameters are treated as local variables, whose values will be given when the function is called.
            <pre>
                <code>
                    let result = add(5, 7);
                    console.log(result); // 12

                </code>
            </pre>
            <p>
                In the example call, we pass the arguments <b id="spePara">5</b> and <b id="spePara">7</b> to the function. Thus, during the function operation, 
                the <b id="spePara">first</b> parameter has a value of <b id="spePara">5</b> and the <b id="spePara">second</b> parameter has a value of <b id="spePara">7</b>. 
                The function returns the value <b id="spePara">12</b> to the result variable.
            </p>
        </p>
        <p>
            You can pass any type of data as arguments to the function, both simple and complex. Let's write the <b id="spePara">getElement</b> function, which will return 
            the selected element from the array, with the array and index of the element being the function's parameters.
            <pre>
                <code>
                    function getElement(elementss,index) {
                        return elementss[index];
                      }
                </code>
            </pre>
            <p>
                Let's call it with sample arguments:
                <pre>
                    <code>
                          let names = ["balcha", "caaltuu", "badhasa", "suleman"];
                          let name_ = getElement(names, 2);
                          //
                          console.log(name_); // badhasa
                          
                    </code>
                </pre>
            </p>
        </p>
        <p>
            Let's go back to the example with mean temperature. The <b id="spePara">get_temp_mean_</b> function will take one parameter – temperatures. At the same time, we will remove the global 
            variable with this name from the program and create two others, <b id="spePara">day1</b> and <b id="spePara">day2</b>, which will contain the measurement data. 
            These data will be passed on to the function.
            <pre>
                <code>
                    function get_temp_mean_7(temperature_7) {
                        let sum_of_Temperature_7 = 0;
                        for (let i = 0; i < temperature_7.length; i++) {
                          sum_of_Temperature_7 += temperature_7[i];
                        }
                        return sum_of_Temperature_7 / temperature_7.length;
                      }
                      //
                      let day_1 = [
                        12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21,
                        20, 19, 17, 16,
                      ];
                      console.log(`mean day1 : ${get_temp_mean_7(day_1)}`); //mean day1 : 16.666666666666668
                      //
                      let day_2 = [
                        17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24,
                        21, 19, 18, 17, 16,
                      ];
                      console.log(`mean day2 : ${get_temp_mean_7(day_2)}`); // mean day2 : 18.083333333333332
                </code>
            </pre>
            <p>
                The first time the <b id="spePara">get_temp_mean_</b> function is called, the <b id="spePara">day1</b> variable is passed on to the <b id="spePara">get_temp_mean_</b> 
                function as an argument. 
                The calculations performed inside the function using the temperatures parameter will therefore be based on the values from the day1 variable. 
                In the second call, we pass another array to the function, stored in the <b id="spePara">day2</b> variable.
                <br><br>
                You can probably already point out one more thing: when calling the console.log method (a function related to the console object) we also pass an argument to it – 
                a string to be displayed on the console. This means that we have been using the parameters of the function since the beginning of the course.
            </p>
        </p>
    </p>
    <h2 id="spePara">SHADOWING</h2>
    <p>
        As we mentioned earlier, the parameters are treated inside the function as local variables. And just like the local variables explicitly declared inside a function, 
        they shadow the global variables of the same name (or more generally, variables from the outer scope). Let's go back for a moment to the example with adding numbers. 
        The <b id="spePara">add</b> function has two parameters: <b id="spePara">first</b> and <b id="spePara">second</b>. At the same time, we will declare, 
        out of the function, global variables named <b id="spePara">first</b>, <b id="spePara">second</b>, <b id="spePara">third</b>, and <b id="spePara">fourth</b>.
        <br><br>
        If inside the function, we refer to the variable:
        <li id="list">
            <b id="spePara">first</b>, it will be treated as the parameter with such a name that shadows the <b id="spePara">first</b> global variable 
            (i.e. we will operate on the value passed as the first argument)
        </li>
        <li id="list">
            <b id="spePara">second</b>, it will also be treated as the function parameter (the value passed as the second argument)
        </li>
        <li id="list">
            <b id="spePara">third</b>, it will be treated as a global variable, because inside the function there is neither a 
            local variable nor a parameter with that name that would shadow it;
        </li>
        <li id="list">
            <b id="spePara">fourth</b>, it will be treated as global, the same as <b id="spePara">third</b>.
        </li>
        <p>
            Of course, outside the function, each of these names will refer to global variables.
            <pre>
                <code>
                    function add(first, second) {
                        return first + second;
                      }
                      //
                      let first = 10,
                        second = 30,
                        third = 50,
                        fourth = 70;
                      console.log(add(first, second)); //40
                      console.log(add(second, third)); //80
                      console.log(add(third, first)); //60
                </code>
            </pre>

        </p>
    </p>

    
</body>
</html>