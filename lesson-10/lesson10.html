<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-10 with Biruk</title>
    <script src="lesson10.js"></script>
    <link rel="stylesheet" href="lesson10.css">
</head>
<body>
    <h1>CONTINUED... [OPERATORS]</h1>
    <h3>
        STRINGS, COMPARISON, AND OTHER <span class="uniq">JS</span> OPERATORS
    </h3>

    <h2>
        1. STRINGS OPERATORS 
    </h2>
    <p>
        The only operator in this group is the " <b>concatenation</b>" +. This operator will convert everything to a String " <b>if any of the operands</b>" is a " <b>String</b>" type. 
        Finally, it will create a new character string, attaching the right operand at the end of the left operand.
        <pre>
            <code>
                const selamta = "Selam";
                console.log(selamta + " " + "Hundee !!");// Selam Hundee !!
                //
                //
                const melikt = "Melkam Addis Amet "
                const melkamMignot = melikt + 2017;
                console.log(melkamMignot);//  Melkam Addis Amet 2017
                //
                console.log(typeof melkamMignot); // STRING
            </code>
        </pre>
    </p>

    <h2 class="h20">
        1.1.COMPOUND ASSIGNMENT OPERATORS
    </h2>
    <p>
        You can probably guess that this operator can also be used in conjunction with the replacement operator. Its operation is so intuitive that we will stop with a simple example:

        <pre>
            <code>
                let weregna = "Mn malet felegeh nw "
                weregna += "biruk ";
                weregna += 101;

                console.log(weregna)
            </code>
        </pre>
    </p>

    <h2>
       2. COMPARISON OPERATORS
    </h2>
    <p>
        Comparison operators are used to check the equality or inequality of values. 
        All comparison operators are binary, and all of them return a logical value representing the result of the comparison, <b>true </b> or <b>false</b>.
        <br>
        It makes sense to check equality, or which is greater, using <b>numeric</b> representation, and JavaScript will in most cases convert types to a <b>Number before comparison</b>.
        <br><br>
        There are <b>two exceptions </b>to this, <b>strings</b> and the <b>identity</b> (strict equality) operator. 
        <br>
        <b>** Strings</b> are compared char by char (precisely Unicode character by Unicode character using their values).
        <br>
        To <b>check</b> if the operands <b>are equal</b>, we can use either the identity ( <b>strict equality</b> ) operator <b>===</b> or the <b>equality</b> operator <b>==</b>.
        <br><br>
        The first is more restrictive, and <b> in order to return true</b>, the <b>operands must be identical</b> (i.e. they must be <b>equal</b> and of <b>the same type</b> ).

        <pre>
            <code>
                console.log(10 === 5); // false
                console.log(10 === 10); // true
                console.log(10 === 10n); // false
                console.log(10 === "10"); // false
                console.log("10" === "10"); // true
                console.log(0 === false); // false
                console.log("biruk" === "fekadu"); // false 
                console.log(undefined === false); // false 
                console.log(null === false); // false
            </code>
        </pre>
        <p>The <b>equality operator</b> requires that they are <b>only equal</b>, and their <b>types are not compared</b>. So if the operands are of <b>different types</b>, the interpreter will try to <b>convert them to numbers</b>, for example, 
           <b>false</b> will convert <b>to 0</b>, <b>true</b> to <b>1</b>, <b>undefined</b> to <b>NaN</b>, <b>null</b> to <b>0</b>, <br>
           ................. <b>10n</b> to <b>10</b> and <b>"123"</b> to <b>123</b>, etc.
        </p>
    </p>
    <p>
        " <b>Note</b>" that if any of the operands has a <b>NaN</b> value (or has been converted to NaN, e.g. with undefined), <b>the equality operator</b> will return <b>false</b>.
        <pre>
            <code>
                        console.log(10 == 5); // FALSE
                        console.log(10 == 10); //TRUE
                        console.log(10 == 10n);//TRUE
                        console.log(10 == "10"); //TRUE
                        console.log("10" == "10"); //TRUE     
                        console.log(0 == false);   //TRUE
                        console.log("biruk" == "fekadu"); //FALSE
                        console.log(undefined == false); //FALSE
                        console.log(null == false);  // FALSE
                        console.log(undefined == true);  //FALSE
            </code>
        </pre>
        <p class="uniq"><b>Remember!</b> Use the identity operator unless you intentionally allow for a positive comparison between the different types.</p>
    </p>
    <p>
        ***There are also <b>complementary operators</b> to those just demonstrated – the <b>nonidentity operator</b> !== and the <b>inequality operator</b> !=. 
        <br>The <b>first</b> returns <b>true if</b> the operands are <b>not identical</b>, in other words, <b>they are equal</b> but of <b>different types</b>, or they are simply different. 
        The <b>second</b> returns <b>true if </b>the <b>operands are different</b>.

        <pre>
            <code>
                        console.log(10 !== 5); // true
                        console.log(10 !== 10); //false
                        console.log(10 !== 10n);//TRUE
                        console.log(10 !== "10"); //TRUE
                        console.log("10" !== "10"); //false     
                        console.log(0 !== false);   //TRUE
                        console.log("biruk" !== "fekadu"); //true
                        console.log(undefined !== false); //true
                        console.log(null !== false);  // true
                        console.log(undefined !== true);  //true
                        <br>
                        console.log(10 != 5); // true
                        console.log(10 != 10); //false
                        console.log(10 != 10n);//TRUE
                        console.log(10 != "10"); //TRUE
                        console.log("10" != "10"); //false     
                        console.log(0 != false);   //TRUE
                        console.log("biruk" != "fekadu"); //true
                        console.log(undefined != false); //true
                        console.log(null != false);  // true
                        console.log(undefined != true);  //true
            </code>
        </pre>
    </p>

    <p>
        ***We also have operators that allow us to <b>check if one of the operands</b> is <b>bigger than</b> ">", <b>smaller than</b> "<", <b>bigger than or equal</b> to ">=", and <b>smaller than or equal</b> to "<=". 
        These operators <b>work on any type</b> of operand, but it makes sense to <b>use them only on numbers</b> or values that will convert correctly to numbers.

        <pre>
            <code>
                console.log(10 > 100); // -> false
                console.log(101 > 100); // -> true
                console.log(101 > "100"); // -> true
                
                console.log(101 < 100); // -> false
                console.log(100n < 102); // -> true
                console.log("10" < 20n); // -> true
                
                console.log(101 <= 100); // -> false
                console.log(10 >= 10n); // -> true
                console.log("10" <=  20); // -> true
            </code>
        </pre>
    </p>

    <p>
        You can also use them <b>to compare strings</b> that do <b>not</b> represent <b>numbers</b>, but the algorithm of this comparison is quite complex, and the comparison itself is not very useful. 
        By way of simplification, <b>single characters of both</b> strings are <b>tested on the same positions</b>. <br><br>
        ***It is assumed that the values of the <b>single characters correspond to their positions in the alphabet</b> (the letter <b>b</b> has a <b>higher</b> value than the letter <b>a</b>). 
        <b>Upper-case letters</b> have <b>lower</b> values than <b>lower-case letters</b>, and <b>digits</b> have even lower values.

        <pre>
            <code>
                console.log("b" > "a"); // -> true
                console.log("a" > "B"); // -> true
                console.log("B" > "A"); // -> true
                console.log("A" > "4"); // -> true
                console.log("4" > "1"); // -> true
                
                console.log("ab1" < "ab4"); // -> true
                console.log("ab4" < "abA"); // -> true
                console.log("abB" < "aba"); // -> true
                console.log("aba" < "abb"); // -> true
                
                console.log("ab" < "ab4"); // -> true
            </code>
        </pre>
        <p class="uniq"><b>Note:</b> the symbol <b>=></b> exists in JavaScript, but is not an operator – we use it in the construction of <b>arrow functions</b>.</p>
    </p>

    <h2>
        3. OTHER JS OPERATORS
    </h2>
    
    <p>
        The list of operators in JavaScript is much longer, but many of them would not be particularly useful at this stage of learning, such as <b>bitwise operators</b>, 
        which operate on single bits of operands. However, it is worth mentioning a few more operators, some of which have already appeared in earlier examples.

            <ul>
                A. typeof
            </ul>
                <p>It is a <b>unary operator</b>, which checks the type of operand (it can be a variable or a literal). The operator returns a string with the type name, <b>such as "boolean" or "number"</b>.

                    If you want to refresh your knowledge of this operator, go back to the section about data types.
                </p>
        
                <pre>
                    <code>
                        const wtf= " what are you talking about";
                            
                        console.log(typeof wtf); // STRING
                        console.log(typeof 10); // NUMBER

                    </code>
                </pre>

                
            <ul>
                B. instanceof
            </ul>   
                <p>
                    The instanceof operator appeared while discussing arrays. It is a binary operator that checks whether an object (left operand) is of some type (right operand). Depending on the test result, it returns true or false.

                    During this course, the usefulness of this operator is limited to testing whether a variable contains an array
                </p>
                <pre>
                    <code>
                        const blabla=[{
                            name:'biruk',
                            age:24
                        }];
                        console.log(blabla instanceof Array); // true
                        console.log(blabla instanceof Object); // true
                        console.log(blabla instanceof String); // false
                    </code>
                </pre>



            <ul>
                c. delete
            </ul>
                <p>
                    The unary delete operator was introduced while discussing objects. It allows you to delete a selected field of the object whose name is indicated with an operand.
                </p>

                <pre>
                    <code>
                        const myPlans =["God ", "Money ","Girlfriend","Google SWE"];
                        console.log(myPlans);   // God , Money , Girlfriend , Google SWE
                        
                        delete myPlans[2]; // Girlfriend is deleted from myPlans
                        console.log("my new plans",myPlans); // God, Money, Google SWE
                    </code>
                </pre>
                    

            <ul>
                d. ternary
            </ul>
                <p>
                    The last of the operators discussed is quite unusual, because it is the <b>only operator using three operands</b>. It is a conditional operator. 
                    Based on the <b>value of the first operand</b> ( <b>true or false</b> ), the <b>value </b>of the <b>second or third operand</b>, respectively, is returned. <br><br> 
                    <b>This operator</b> is most often used <b>to place one of the two</b> values in the variable <b>depending on</b> a certain <b>condition</b>. 
                    We will come back to the operator when discussing the conditional if, but here we’ll provide only a simple example of its use. 
                    The three operands are separated from each other by ? (the first from the second) and : (the second from the third).
                </p>

                <pre>
                    <code>   
                        console.log(true ? "Biruk" : "roro"); // Biruk
                        console.log(false ? "Biruk" : "roro"); // roro

                    </code>
                </pre>
                    <p>
                        Each of these operands can be an <b>expression that must</b> be calculated.In the following example, <b>the first operand</b> is a <b>comparison of two numbers</b> using a comparison operator. 
                        The <b>result</b> of the comparison will be <b>false</b>, which will be used by the conditional (ternary) operator.
                    </p>
                    
                    <pre>
                        <code>

                        </code>
                    </pre>
    </p>

    <h2 class="precedence">
        4.PRECEDENCE 
    </h2>
    <p>
        Practically in all the examples where we presented the <b>operation of successive operators</b>, we followed instructions in which one operator was used. In reality, usually multiple operators are used simultaneously. 
        At this point, a quite important question arises: in what order will the interpreter perform them? This will of course affect the final result of the operators, so it is worth taking this into account when writing the instructions.

        <pre>
            <code>
                let a = 10;
                let b = a + 2 * 3;
                let c = a + 2 < 20 -15;
                //
                console.log(a); // 10
                console.log(b); // 16 
                console.log(c); // false
            </code>
        </pre>
        
    </p>
    <div>
        <p>
            In the <b>second line</b> of the example (<b>variable b declaration</b> ), the operators are executed in the order we know from mathematics. <b>First</b>, <b>multiplication is performed</b>, <b>then addition</b>, and at the end the resulting value is assigned to the variable. 
            In the <b>third line</b> (declaration of <b>variable c</b> ) the matter gets a little more complicated. <b>First</b>, the <b>sum of</b> variable <b>a </b>and <b>number 2</b> is calculated, <b>then</b> the <b>sum of</b> numbers <b>20 </b>and <b>15,</b> and <b>both results</b> are compared with the logical operator (less than) and the result is placed in variable c.
                <br><br>
            The <b>JavaScript inter</b>preter uses <b>two operator properties to determine</b> the <b>sequence of</b> operations: <b>precedence</b> and <b>associativity</b>. Precedence can be treated as a priority, with some operators having the same precedence (e.g. addition and subtraction). 
            Associativity allows you to specify the order of execution if there are several operators with the same priorities next to each other.

            Precedence can be presented as a numerical value – the higher the value, the higher the priority of the operation. If, for example, an OP1 operator has a smaller precedence than OP2, then the instruction:

            <pre><code>
                a OP1 b OP2 c
            </code></pre>
            will be <b>executed</b> as follows: <b>first</b>, <b>OP2</b> will be executed <b>on</b> operands <b>b</b> and <b>c</b>, <b>then OP1</b> will be <b>executed on</b> the <b>left operand "a"</b> and the <b>right</b> operand, <b>resulting from OP2</b>. So the instruction could be presented in the form:

            <pre><code>
                a OP1 ( b OP2 c)
            </code></pre>
            If we <b>perform the same operation</b>s (or <b>different operations </b>but with the <b>same precedence</b> ), the <b>interpreter uses associativity</b> to <b>determine</b> the <b>order of operations</b>. Operators may have a <b>specified left-associativity</b> (<b>left to right order</b>) or <b>right-associativity</b> (<b>right to left order</b>). 
            Let's assume that in our example, the operator OP1 has left-associativity:

            <pre><code>
                a OP1 b OP2 c
            </code></pre>
            In such a situation, the <b>OP1</b> operation on operands <b>a and b</b> will be <b>performed first</b>, <b>followed</b> by a <b>second OP1 operation on the received result and operand c</b>. Bearing in mind that we are dealing with <b>left-associativity</b>, we could write the instruction in the following form:

            <pre><code>
                (a OP1 b) OP2 c
            </code></pre>
            <b>It follows</b> that it would be appropriate to know <b>not only the precedence of all operators</b>, but <b>also their associativity</b>. This may seem a bit overwhelming, taking into <b>account the number of operators</b>. 
            <br><br>
            <b>Fortunately</b>, it <b>is</b> usually <b>enough to know</b> the <b>properties of the most basic operators</b> and <b>use brackets in doubtful situations</b>. 
            The <b>brackets</b> allow you to <b>impose the order</b> of operations, just <b>like in mathematics</b>. 
            <br><br>
            <b>*****Keep this in mind</b> when viewing the table provided in image (find it in your lesson-10 folder ). <b>It contains</b> a <b>list</b> of operators we already know with <b>their precedence</b> and <b>associativity</b>, so it is quite large. You absolutely do not have to remember everything if you can use brackets to group operations.
        </p>
    </div>
<!-- <img src="precedenceTable.png" alt=""> -->


    
</body>
</html>