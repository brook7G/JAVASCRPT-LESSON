<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-18 with Biruk</title>
    <script src="lesson18.js"></script>
    <link rel="stylesheet" href="/lesson-16/lesson16.css">
    <img id="norImg" src="/JavaScript-logo.png" alt="">
</head>
<body>
    <h1 id="speH1">LESSON-18: <span>FUNCTIONS</span></h1>
    <u id="speH1"><h2>PART-2</h2></u>
    <h2 id="spePara">PARAMETERS VALIDATION</h2>
    <p>
        Remember how we said that we sometimes use the return keyword to interrupt functions in the case of errors? A good example is the validation of function parameters.
        <br><br>
        Let's go back to the example with the <b id="spePara">get_temp_mean_</b> function. The last version we wrote needs an array of numbers as an argument. Before starting the calculation, 
        we can check if the value passed to it is actually an array.
        <pre>
            <code>
                function get_temperature_mean_(temperatures) {
                    if (!(temperatures instanceof Array)) {
                      return NaN;
                    }
                    let sum_of_Temperatures_ = 0;
                    for (let i = 0; i < temperatures.length; i++) {
                      sum_of_Temperatures_ += temperatures[i];
                    }
                    return sum_of_Temperatures_ / temperatures.length;
                  }
                  //
                  console.log(get_temperature_mean_(10)); //NaN
                  console.log(get_temperature_mean_([10, 30])); // 20
                  
            </code>
        </pre>
    </p>
    <h2 id="spePara">RECURSION</h2>
    <p>
        During your math lessons, you probably came across the concept of factorials. A factorial is a function, indicated by an exclamation mark in mathematical notation. 
        We pass an integer to this function and its result is obtained by multiplying all integers from the number 1 to the number given as an argument. 
        Formally, you define a factorial as follows:
        <pre>
            <code id="spePara">
                n!=n∙(n-1)∙(n-2)∙... ∙2∙1

                So, for example, the factorial of 6 is:

                6!=6∙5∙4∙3 ∙2∙1=720
            </code>
        </pre>
        <p>
            Let's try to write a function that will calculate the factorial from the given number.
            <br><br>
            It will take the parameter n and return the calculated value.
            <pre>
                <code>
                    function factorial(num) {
                        let result = 1;
                        while (num > 1) {
                          result *= num;
                          num--;
                        }
                        return result;
                      }
                      console.log(factorial(5)); // 120
                </code>
            </pre>
            <p>
                In this case, we use the iterative approach to calculate the factorial, in other words, we use a loop in which, 
                during each iteration we multiply the previous result by another element of the sequence.
                <br><br>
                After the first iteration, the result is 6, after the second, 30, after the third, 120, and so on. 
                The iterations are repeated to the last significant element of the 
                sequence, that is, to the value 2 (hence the condition of ending the loop n > 1).
            </p>
        </p>
        <p>
            However, the definition of a factorial can be written in a slightly different way. 
            It will be the factorial of the previous element <b id="noticed">n - 1</b> multiplied by <b id="">n</b>.
            <br><br>
            <b id="front">For example</b>, 6! is 5! multiplied by 6. Such a factorial definition uses the recursion, 
            i.e. referring a function to itself (but with a different argument). 
            A recursion is a mechanism that allows to simplify the formal notation of many mathematical functions and present them in an elegant form. 
            We can also successfully use recursion in programming.
            <br><br>
            Let's declare the <b id="spePara">factorial</b> function again, this time using recursion.
            <pre>
                <code>
                    function factorial_1(num_1) {
                        return num_1 > 1 ? num_1 * factorial_1(num_1 - 1) : 1;
                      }
                      console.log(`factorial of num1: [${factorial_1(4)}]`); // factorial of num1: [24]
                </code>
            </pre>
        </p>
        <p>
            In order to get a shorter, more compact code, instead of an if conditional instruction, we use the ternary conditional operator. 
            In it, we check if the argument n is greater than 1. Depending on that, we return either the result of multiplying the number n by 
            the result of the factorial(n – 1) call, or the value 1. The figure below shows a sequence of factorial function calls starting 
            from a call for the value 6 (the arrows show where the value from the called function is returned)
            <img src="/lesson-18/factorial.png" alt="">
            Recursion is commonly used in programming. However, as with any solution, recursion must be handled with care. 
            We shouldn't use it where we can't estimate the number of embedded calls.
            <br><br>
            We should also be very careful in formulating the condition that will interrupt the function sequence calls – 
            errors can cause the program to suspend.
        </p>
    </p>
    <h2 id="spePara">FUNCTIONS AS FIRST-CLASS MEMBERS</h2>
    <p>
        In JavaScript, functions are first-class members. This term means that functions can be treated as any data, 
        which can be stored in variables or passed as arguments to other functions. For example, 
        we can declare the showMessage function and then store it in the variable <b id="spePara">sm</b>.
        <pre>
            <code>
                function showMessage(message) {
                    console.log(`Message: ${message}`);
                  }
                  //
                  let sm = showMessage;
            </code>
        </pre>
        <p>
            We can store any function that is accessible in this scope in a variable and use a 
            function call operator () to execute it. We can check that the sm variable is now a function 
            by using the typeof operator.
            <pre>
                <code id="spePara">
                    sm("THIS IS BULLSHIT"); // Message: THIS IS BULLSHIT
                    console.log(typeof sm); // function
                </code>
            </pre>
        </p>
        <p>
            But it’s important to remember that when assigning a function to a variable, we don't use a function call operator, 
            as this would execute the function and assign the result of the function to a variable, and not to the function itself.
            <pre>
                <code>
                    function do_nothing() {
                        return undefined; //
                      }
                      //
                      let a = do_nothing(); // assign result of function call
                      let b = do_nothing; // assign function
                      //
                      console.log("type-of -a :", typeof a); // type-of -a : undefined
                      console.log("type-of -b :", typeof b); // type-of -b : function
                </code>
            </pre>
        </p>
        <p>
            In the example, the result of the doNothing function call (i.e. the undefined value returned by the function) is 
            stored in the a variable, while the doNothing function itself is stored in the b variable (or more precisely, a 
            reference to the function is stored in the b variable).
            <br><br>
            This property is especially useful when passing the function as a call parameter to other functions, 
            which we will soon learn more about. For now, let's test that something like this is actually feasible.
            <pre>
                <code>
                    function add(a, b) {
                        return a + b;
                      }
                      function multipy(a, b) {
                        return a * b;
                      }
                      function divide(a, b) {
                        return a / b;
                      }
                      function operation(func, first, second) {
                        return func(first, second);
                      }
                      
                      console.log(operation(add, 10, 20)); // 30
                      console.log(operation(multipy, 10, 20)); // 200
                      console.log(operation(divide, 10, 20)); // 0.5
                </code>
            </pre>
            <p>
                The operation function takes as its first argument the function (parameter func) and 
                calls it with the other two arguments passed (parameters first and second).
            </p>
        </p>
    </p>
    <h2 id="spePara">FUNCTIONS EXPRESSIONS</h2>
    <p>
        To store a function in a variable or pass it as an argument to call a function, 
        you do not necessarily have to declare it previously and use its name.
        <br><br>
        Let's go back to our example with the add function:
        <pre>
            <code>
                function add_1(a, b) {
                    return a + b;
                  }
                  //
                  let myAdd_1 = add_1;
                  console.log(myAdd_1(10, 20)); // 30
                  console.log(add_1(10, 30)); // 40
                  
            </code>
        </pre>
        <p>
            We first declare the add function, and then store it in the variable <b id="spePara">myAdd_1</b>. 
            We can call the same function using both the name add and the variable <b id="spePara">myAdd_1</b>. 
            We can shorten this notation and declare the function by storing it in a variable.
            <pre>
                <code>
                    let myAdd_2 = function add2(a, b) {
                        return a + b;
                      };
                      //
                      console.log(myAdd_2(40, 20)); //60
                      console.log(add2(80, 20)); //100
                </code>
            </pre>
            <p>
                In the example, we again declare the add function, and at the same time store it in the myAdd variable.
                <br><br>
                This form of defining a function is called function expression. In this case, it is specifically a named 
                function expression, because the function has a name (add). If there is a named function expression, 
                there will probably also be an unnamed, or precisely, an anonymous function expression. In fact, simply 
                remove the name following the function keyword to change the function from named to anonymous.
                <pre>
                    <code>
                        let myAdd_3 = function (a, b) {
                            return a + b;
                          };
                          //
                          console.log(myAdd_3(30, 50)); // 80
                    </code>
                </pre>
            </p>
        </p>
        <p>
            Let's go back to the concept of anonymous functions. It may seem a little incomprehensible when you use a 
            name (although it is a variable name) to refer to a function. In this case, it's about anonymity, 
            i.e. the lack of a name, in the very definition of a function. This will be much more evident when passing a function as a 
            call parameter to another function.
            <br><br>
            Let's look at the example:
            <pre>
                <code>
                    function operation_2(func, first, second) {
                        return func(first, second);
                      }
                      //
                      let myAdd_4 = function (a, b) {
                        return a + b;
                      };
                      //
                      //
                      console.log(operation_2(myAdd_4, 20, 50)); // 70
                      //
                      console.log(
                        operation_2(
                          function (a, b) {
                            return a * b;
                          },
                          90,
                          10
                        )
                      ); // 900
                </code>
            </pre>
        </p>
    </p>

</body>
</html>