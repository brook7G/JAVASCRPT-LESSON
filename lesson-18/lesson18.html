<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-18 with Biruk</title>
    <script src="lesson18.js"></script>
    <link rel="stylesheet" href="/lesson-16/lesson16.css">
    <img id="norImg" src="/JavaScript-logo.png" alt="">
</head>
<body>
    <h1 id="speH1">LESSON-18: <span>FUNCTIONS</span></h1>
    <u id="speH1"><h2>PART-2</h2></u>
    <h2 id="spePara">PARAMETERS VALIDATION</h2>
    <p>
        Remember how we said that we sometimes use the return keyword to interrupt functions in the case of errors? A good example is the validation of function parameters.
        <br><br>
        Let's go back to the example with the <b id="spePara">get_temp_mean_</b> function. The last version we wrote needs an array of numbers as an argument. Before starting the calculation, 
        we can check if the value passed to it is actually an array.
        <pre>
            <code>
                function get_temperature_mean_(temperatures) {
                    if (!(temperatures instanceof Array)) {
                      return NaN;
                    }
                    let sum_of_Temperatures_ = 0;
                    for (let i = 0; i < temperatures.length; i++) {
                      sum_of_Temperatures_ += temperatures[i];
                    }
                    return sum_of_Temperatures_ / temperatures.length;
                  }
                  //
                  console.log(get_temperature_mean_(10)); //NaN
                  console.log(get_temperature_mean_([10, 30])); // 20
                  
            </code>
        </pre>
    </p>
    <h2 id="spePara">RECURSION</h2>
    <p>
        During your math lessons, you probably came across the concept of factorials. A factorial is a function, indicated by an exclamation mark in mathematical notation. 
        We pass an integer to this function and its result is obtained by multiplying all integers from the number 1 to the number given as an argument. 
        Formally, you define a factorial as follows:
        <pre>
            <code id="spePara">
                n!=n∙(n-1)∙(n-2)∙... ∙2∙1

                So, for example, the factorial of 6 is:

                6!=6∙5∙4∙3 ∙2∙1=720
            </code>
        </pre>
        <p>
            Let's try to write a function that will calculate the factorial from the given number.
            <br><br>
            It will take the parameter n and return the calculated value.
            <pre>
                <code>
                    function factorial(num) {
                        let result = 1;
                        while (num > 1) {
                          result *= num;
                          num--;
                        }
                        return result;
                      }
                      console.log(factorial(5)); // 120
                </code>
            </pre>
            <p>
                In this case, we use the iterative approach to calculate the factorial, in other words, we use a loop in which, 
                during each iteration we multiply the previous result by another element of the sequence.
                <br><br>
                After the first iteration, the result is 6, after the second, 30, after the third, 120, and so on. 
                The iterations are repeated to the last significant element of the 
                sequence, that is, to the value 2 (hence the condition of ending the loop n > 1).
            </p>
        </p>
        <p>
            However, the definition of a factorial can be written in a slightly different way. 
            It will be the factorial of the previous element <b id="noticed">n - 1</b> multiplied by <b id="">n</b>.
            <br><br>
            <b id="front">For example</b>, 6! is 5! multiplied by 6. Such a factorial definition uses the recursion, 
            i.e. referring a function to itself (but with a different argument). 
            A recursion is a mechanism that allows to simplify the formal notation of many mathematical functions and present them in an elegant form. 
            We can also successfully use recursion in programming.
            <br><br>
            Let's declare the <b id="spePara">factorial</b> function again, this time using recursion.
            <pre>
                <code>
                    function factorial_1(num_1) {
                        return num_1 > 1 ? num_1 * factorial_1(num_1 - 1) : 1;
                      }
                      console.log(`factorial of num1: [${factorial_1(4)}]`); // factorial of num1: [24]
                </code>
            </pre>
        </p>
        <p>
            In order to get a shorter, more compact code, instead of an if conditional instruction, we use the ternary conditional operator. 
            In it, we check if the argument n is greater than 1. Depending on that, we return either the result of multiplying the number n by 
            the result of the factorial(n – 1) call, or the value 1. The figure below shows a sequence of factorial function calls starting 
            from a call for the value 6 (the arrows show where the value from the called function is returned)
            <img src="/lesson-18/factorial.png" alt="">
            Recursion is commonly used in programming. However, as with any solution, recursion must be handled with care. 
            We shouldn't use it where we can't estimate the number of embedded calls.
            <br><br>
            We should also be very careful in formulating the condition that will interrupt the function sequence calls – 
            errors can cause the program to suspend.
        </p>
    </p>
    <h2 id="spePara">FUNCTIONS AS FIRST-CLASS MEMBERS</h2>
    <p>
        In JavaScript, functions are first-class members. This term means that functions can be treated as any data, 
        which can be stored in variables or passed as arguments to other functions. For example, 
        we can declare the showMessage function and then store it in the variable <b id="spePara">sm</b>.
        <pre>
            <code>
                function showMessage(message) {
                    console.log(`Message: ${message}`);
                  }
                  //
                  let sm = showMessage;
            </code>
        </pre>
        <p>
            We can store any function that is accessible in this scope in a variable and use a 
            function call operator () to execute it. We can check that the sm variable is now a function 
            by using the typeof operator.
            <pre>
                <code id="spePara">
                    sm("THIS IS BULLSHIT"); // Message: THIS IS BULLSHIT
                    console.log(typeof sm); // function
                </code>
            </pre>
        </p>
        <p>
            But it’s important to remember that when assigning a function to a variable, we don't use a function call operator, 
            as this would execute the function and assign the result of the function to a variable, and not to the function itself.
            <pre>
                <code>
                    function do_nothing() {
                        return undefined; //
                      }
                      //
                      let a = do_nothing(); // assign result of function call
                      let b = do_nothing; // assign function
                      //
                      console.log("type-of -a :", typeof a); // type-of -a : undefined
                      console.log("type-of -b :", typeof b); // type-of -b : function
                </code>
            </pre>
        </p>
    </p>

</body>
</html>